# ********RoostGPT********
"""
Test generated by RoostGPT for test pyFlinkTest using AI Type Azure Open AI and AI Model roostgpt-4-32k

Test generated by RoostGPT for test pyFlinkTest using AI Type Azure Open AI and AI Model roostgpt-4-32k

ROOST_METHOD_HASH=to_milliseconds_since_epoch_7d450a2668
ROOST_METHOD_SIG_HASH=to_milliseconds_since_epoch_b5fa793f61


```
Scenario 1: Verify correct conversion when input timestamp is the Unix Epoch
Details:
  TestName: test_conversion_on_epoch
  Description: This test verifies that the conversion function returns 0 when given the Unix Epoch, the point in time from which the Milliseconds Since Epoch is usually calculated.
Execution:
  Arrange: Retrieve the DateTime representation of the Unix Epoch (1970-01-01T00:00:00Z).
  Act: Invoke the to_milliseconds_since_epoch function, passing the Unix Epoch DateTime object.
  Assert: Check that the returned value is 0.
Validation:
  This test is important because it verifies that the function correctly handles the base case from which the outputs are calculated. If the function does not return 0 for this case, it is likely incorrectly implemented.

Scenario 2: Verify correct conversion for timestamps occurring after the Unix Epoch
Details:
  TestName: test_conversion_on_post_epoch_timestamp
  Description: This test verifies that the conversion function returns a positive integer when given a timestamp that occurs after the Unix Epoch.
Execution:
  Arrange: Create a DateTime object that is set to a time after the Unix Epoch.
  Act: Invoke the to_milliseconds_since_epoch function, passing the post-Epoch DateTime object.
  Assert: Check that the returned value is a positive integer.
Validation:
  Verifying this behavior is important as most timestamps fall into this category. If the function does not return a positive integer for post-Epoch timestamps, it is incorrectly implemented.

Scenario 3: Verify correct conversion for timestamps occurring before the Unix Epoch
Details:
  TestName: test_conversion_on_pre_epoch_timestamp
  Description: This test verifies that the conversion function returns a negative integer when given a timestamp that occurs before the Unix Epoch.
Execution:
  Arrange: Create a DateTime object that is set to a time before the Unix Epoch.
  Act: Invoke the to_milliseconds_since_epoch function, passing the pre-Epoch DateTime object.
  Assert: Check that the returned value is a negative integer.
Validation:
  This test ensures that the function correctly handles timestamps from before the Unix Epoch, an edge case that could be encountered during use.

Scenario 4: Verify function accuracy by comparing against a known good value
Details:
  TestName: test_conversion_on_known_good_value
  Description: This test verifies that the conversion function returns correct, precise values by comparing the function's output with known good values.
Execution:
  Arrange: Create a DateTime object for a known time stamp (for instance, 2022-03-14T16:05:30Z) and calculate its Milliseconds since Epoch value.
  Act: Invoke the to_milliseconds_since_epoch function, passing the prepared DateTime object
  Assert: Check that the returned value is equal to the known good value.
Validation:
  This test is crucial for ensuring that the function is accurate, not merely returning plausible outputs.

"""

# ********RoostGPT********
import pytest
import datetime as dt
from common_utils.date import to_milliseconds_since_epoch

class Test_DateToMillisecondsSinceEpoch:
    
    @pytest.mark.regression
    def test_conversion_on_epoch(self):
        unix_epoch_timestamp = dt.datetime(1970, 1, 1, tzinfo=dt.timezone.utc)
        assert to_milliseconds_since_epoch(unix_epoch_timestamp) == 0

    @pytest.mark.regression
    def test_conversion_on_post_epoch_timestamp(self):
        post_epoch_timestamp = dt.datetime(1980, 1, 1, tzinfo=dt.timezone.utc)
        assert to_milliseconds_since_epoch(post_epoch_timestamp) > 0

    @pytest.mark.regression
    def test_conversion_on_pre_epoch_timestamp(self):
        pre_epoch_timestamp = dt.datetime(1960, 1, 1, tzinfo=dt.timezone.utc)
        assert to_milliseconds_since_epoch(pre_epoch_timestamp) < 0

    @pytest.mark.regression
    def test_conversion_on_known_good_value(self):
        known_good_timestamp = dt.datetime(2022, 3, 14, 16, 5, 30, tzinfo=dt.timezone.utc)
        # Milliseconds Since Epoch for the known_good_timestamp as per 
        # https://currentmillis.com/ is 1647373530000
        known_good_value = 1647373530000
        assert to_milliseconds_since_epoch(known_good_timestamp) == known_good_value
